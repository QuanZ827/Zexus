using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;

namespace Zexus.Services
{
    /// <summary>
    /// Tracks tool usage data for data-driven tool evolution.
    ///
    /// The report generated by this class is consumed by Claude Code (AI),
    /// not humans. It must contain enough structured data for the AI to
    /// autonomously decide which ExecuteCode patterns should become atomic tools.
    ///
    /// File location: %APPDATA%\Zexus\usage_log.jsonl
    /// Format: One JSON object per line (append-only, never rewritten).
    /// </summary>
    public static class UsageTracker
    {
        private static readonly string LogDirectory;
        private static readonly string LogFilePath;
        private static readonly object _lock = new object();

        // In-memory counters for quick access (reset on Revit restart)
        private static readonly Dictionary<string, int> _sessionCounts =
            new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        // Sequence tracking for retry detection and workflow chains
        private static int _sequenceNumber = 0;
        private static readonly string _sessionId = Guid.NewGuid().ToString("N").Substring(0, 8);
        private static string _currentTurnId = null;

        // Known Revit API patterns to detect in ExecuteCode calls
        private static readonly Dictionary<string, string> ApiPatterns = new Dictionary<string, string>
        {
            // Query patterns
            ["FilteredElementCollector"] = "element_query",
            ["GetWarnings"] = "warnings",
            ["OfCategory"] = "category_filter",
            ["WhereElementIsNotElementType"] = "instance_filter",
            ["GetRoomAtPoint"] = "spatial_query",
            ["get_BoundingBox"] = "geometry_query",
            ["get_Location"] = "location_query",
            ["get_Geometry"] = "geometry_extraction",

            // Parameter patterns
            ["LookupParameter"] = "parameter_read",
            ["get_Parameter"] = "parameter_read",
            ["BuiltInParameter"] = "builtin_parameter",
            ["AsString()"] = "param_as_string",
            ["AsDouble()"] = "param_as_double",
            ["AsElementId()"] = "param_as_element_id",
            ["Set("] = "parameter_write",

            // Document patterns
            ["Transaction"] = "transaction",
            ["doc.Create"] = "element_creation",
            ["doc.Delete"] = "element_deletion",

            // View/Sheet patterns
            ["ViewSheet"] = "sheet_operation",
            ["Viewport"] = "viewport_operation",
            ["ViewFamilyType"] = "view_creation",
            ["ViewSchedule"] = "schedule_operation",

            // Selection patterns
            ["uiDoc.Selection"] = "selection_operation",
            ["PickObject"] = "user_pick",

            // Export patterns
            ["Export"] = "export_operation",
            ["StringBuilder"] = "text_aggregation",
        };

        static UsageTracker()
        {
            LogDirectory = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "Zexus");

            LogFilePath = Path.Combine(LogDirectory, "usage_log.jsonl");
        }

        /// <summary>
        /// Mark the start of a new conversation turn (user message).
        /// Groups all subsequent tool calls under one turn for sequence analysis.
        /// </summary>
        public static void StartConversationTurn()
        {
            _currentTurnId = DateTime.UtcNow.Ticks.ToString("x");
        }

        /// <summary>
        /// Record a user's natural language request.
        /// </summary>
        public static void RecordUserRequest(string message)
        {
            if (string.IsNullOrWhiteSpace(message)) return;

            var entry = new Dictionary<string, object>
            {
                ["timestamp"] = DateTime.UtcNow.ToString("o"),
                ["session_id"] = _sessionId,
                ["turn_id"] = _currentTurnId ?? "unknown",
                ["type"] = "user_request",
                ["message"] = message.Length > 500 ? message.Substring(0, 500) + "..." : message
            };

            WriteEntry(entry);
        }

        /// <summary>
        /// Record a tool call with full error context for AI-driven analysis.
        /// </summary>
        public static void RecordToolCall(
            string toolName,
            Dictionary<string, object> input,
            bool success,
            string errorType = null,
            string errorCategory = null,
            string errorSnippet = null,
            string resultMessage = null,
            long durationMs = 0)
        {
            // Update in-memory counter
            lock (_lock)
            {
                if (!_sessionCounts.ContainsKey(toolName))
                    _sessionCounts[toolName] = 0;
                _sessionCounts[toolName]++;
            }

            var entry = new Dictionary<string, object>
            {
                ["timestamp"] = DateTime.UtcNow.ToString("o"),
                ["session_id"] = _sessionId,
                ["turn_id"] = _currentTurnId ?? "unknown",
                ["seq"] = Interlocked.Increment(ref _sequenceNumber),
                ["tool"] = toolName,
                ["success"] = success,
                ["duration_ms"] = durationMs,
            };

            // For ExecuteCode, analyze the code to detect API patterns
            if (toolName.Equals("ExecuteCode", StringComparison.OrdinalIgnoreCase)
                && input != null
                && input.ContainsKey("code"))
            {
                var code = input["code"]?.ToString() ?? "";
                var detectedPatterns = DetectApiPatterns(code);
                entry["api_patterns"] = detectedPatterns;
                entry["code_length"] = code.Length;

                if (input.ContainsKey("description"))
                    entry["description"] = input["description"]?.ToString() ?? "";

                // Logical failure detection: success=true but suspicious output
                if (success && !string.IsNullOrEmpty(resultMessage))
                {
                    var logicalWarning = DetectLogicalWarning(resultMessage);
                    if (logicalWarning != null)
                        entry["logical_warning"] = logicalWarning;
                }
            }

            // Error information
            if (!success)
            {
                if (!string.IsNullOrEmpty(errorType))
                    entry["error_type"] = errorType;
                if (!string.IsNullOrEmpty(errorCategory))
                    entry["error_category"] = errorCategory;
                if (!string.IsNullOrEmpty(errorSnippet))
                    entry["error_snippet"] = errorSnippet.Length > 200
                        ? errorSnippet.Substring(0, 200)
                        : errorSnippet;
            }

            WriteEntry(entry);
        }

        /// <summary>
        /// Detect "logical failures" — ExecuteCode success=true but suspicious output.
        /// </summary>
        private static string DetectLogicalWarning(string resultMessage)
        {
            if (string.IsNullOrEmpty(resultMessage)) return "no_output";

            if (resultMessage == "Code executed successfully (no output).")
                return "no_output";

            if (Regex.IsMatch(resultMessage,
                @"\b(found|updated|modified|set|changed|processed|deleted|created|tagged)\s+0\b",
                RegexOptions.IgnoreCase))
                return "zero_results";

            return null;
        }

        /// <summary>
        /// Detect which Revit API patterns appear in ExecuteCode's generated code.
        /// </summary>
        private static List<string> DetectApiPatterns(string code)
        {
            var detected = new List<string>();
            foreach (var kvp in ApiPatterns)
            {
                if (code.Contains(kvp.Key))
                {
                    if (!detected.Contains(kvp.Value))
                        detected.Add(kvp.Value);
                }
            }
            return detected;
        }

        /// <summary>
        /// Get a summary of usage data for analysis.
        /// </summary>
        public static Dictionary<string, object> GetSummary()
        {
            var summary = new Dictionary<string, object>();

            lock (_lock)
            {
                summary["session_tool_counts"] = new Dictionary<string, int>(_sessionCounts);
            }

            try
            {
                if (File.Exists(LogFilePath))
                {
                    var lines = File.ReadAllLines(LogFilePath);
                    summary["total_entries"] = lines.Length;
                }
            }
            catch (Exception ex)
            {
                summary["log_error"] = ex.Message;
            }

            return summary;
        }

        #region Report Generation

        /// <summary>
        /// Internal class for parsed JSONL entries.
        /// </summary>
        private class ParsedEntry
        {
            public string Timestamp;
            public string SessionId;
            public string TurnId;
            public string Type; // "user_request" or null (tool call)
            public string Tool;
            public int Seq;
            public bool Success;
            public long DurationMs;
            public List<string> ApiPatterns = new List<string>();
            public string Description;
            public string ErrorType;
            public string ErrorCategory;
            public string ErrorSnippet;
            public string LogicalWarning;
            public string Message; // user request text
        }

        /// <summary>
        /// Generate a structured usage report optimized for AI consumption.
        /// Claude Code reads this report and autonomously decides which
        /// ExecuteCode patterns should become new atomic tools.
        /// </summary>
        public static string GenerateReport()
        {
            if (!File.Exists(LogFilePath))
                return null;

            string[] lines;
            lock (_lock)
            {
                lines = File.ReadAllLines(LogFilePath);
            }

            if (lines.Length == 0)
                return null;

            // === Pass 1: Parse all entries ===
            var entries = new List<ParsedEntry>();
            foreach (var line in lines)
            {
                try
                {
                    var parsed = ParseEntry(line);
                    if (parsed != null)
                        entries.Add(parsed);
                }
                catch { /* skip malformed */ }
            }

            if (entries.Count == 0)
                return null;

            var toolEntries = entries.Where(e => e.Type == null && e.Tool != null).ToList();
            var userRequests = entries.Where(e => e.Type == "user_request").ToList();
            var execCodeEntries = toolEntries.Where(e =>
                e.Tool.Equals("ExecuteCode", StringComparison.OrdinalIgnoreCase)).ToList();

            var sb = new StringBuilder();

            // === Header ===
            var firstTs = entries.First().Timestamp;
            var lastTs = entries.Last().Timestamp;
            var from = DateTime.TryParse(firstTs, out var f) ? f.ToLocalTime().ToString("yyyy-MM-dd HH:mm") : firstTs;
            var to = DateTime.TryParse(lastTs, out var t) ? t.ToLocalTime().ToString("yyyy-MM-dd HH:mm") : lastTs;

            sb.AppendLine("## Zexus_USAGE_REPORT");
            sb.AppendLine($"period: {from} → {to}");
            sb.AppendLine($"total_tool_calls: {toolEntries.Count}");
            sb.AppendLine($"total_user_requests: {userRequests.Count}");
            sb.AppendLine();

            // === Pass 2: Tool call frequency ===
            WriteToolCallFrequency(sb, toolEntries);

            // === Pass 3: ExecuteCode failure breakdown ===
            WriteExecuteCodeBreakdown(sb, execCodeEntries);

            // === Pass 4: API pattern failure rates ===
            WriteApiPatternFailureRates(sb, execCodeEntries);

            // === Pass 5: Retry sequences ===
            WriteRetrySequences(sb, execCodeEntries);

            // === Pass 6: Tool call sequences ===
            WriteToolCallSequences(sb, toolEntries);

            // === Pass 7: Common error messages ===
            WriteCommonErrors(sb, toolEntries);

            // === Pass 8: Tool evolution candidates ===
            WriteToolEvolutionCandidates(sb, execCodeEntries, toolEntries);

            // === User requests ===
            if (userRequests.Count > 0)
            {
                sb.AppendLine("## RECENT_USER_REQUESTS");
                var recent = userRequests.Skip(Math.Max(0, userRequests.Count - 20)).ToList();
                for (int i = 0; i < recent.Count; i++)
                    sb.AppendLine($"  {i + 1}. {recent[i].Message}");
                sb.AppendLine();
            }

            // === Metadata ===
            sb.AppendLine("## REPORT_METADATA");
            sb.AppendLine($"generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"machine: {Environment.MachineName}");
            sb.AppendLine($"user: {Environment.UserName}");
            sb.AppendLine($"session_id: {_sessionId}");
            sb.AppendLine($"log_entries: {entries.Count}");

            return sb.ToString();
        }

        private static ParsedEntry ParseEntry(string line)
        {
            var obj = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(line);
            if (obj == null) return null;

            var entry = new ParsedEntry();

            if (obj.ContainsKey("timestamp"))
                entry.Timestamp = obj["timestamp"].GetString();
            if (obj.ContainsKey("session_id"))
                entry.SessionId = obj["session_id"].GetString();
            if (obj.ContainsKey("turn_id"))
                entry.TurnId = obj["turn_id"].GetString();
            if (obj.ContainsKey("seq") && obj["seq"].ValueKind == JsonValueKind.Number)
                entry.Seq = obj["seq"].GetInt32();

            // User request
            if (obj.ContainsKey("type") && obj["type"].GetString() == "user_request")
            {
                entry.Type = "user_request";
                if (obj.ContainsKey("message"))
                    entry.Message = obj["message"].GetString();
                return entry;
            }

            // Tool call
            if (obj.ContainsKey("tool"))
                entry.Tool = obj["tool"].GetString();
            if (obj.ContainsKey("success"))
                entry.Success = obj["success"].GetBoolean();
            if (obj.ContainsKey("duration_ms") && obj["duration_ms"].ValueKind == JsonValueKind.Number)
                entry.DurationMs = obj["duration_ms"].GetInt64();
            if (obj.ContainsKey("description"))
                entry.Description = obj["description"].GetString();
            if (obj.ContainsKey("error_type"))
                entry.ErrorType = obj["error_type"].GetString();
            if (obj.ContainsKey("error_category"))
                entry.ErrorCategory = obj["error_category"].GetString();
            if (obj.ContainsKey("error_snippet"))
                entry.ErrorSnippet = obj["error_snippet"].GetString();
            if (obj.ContainsKey("logical_warning"))
                entry.LogicalWarning = obj["logical_warning"].GetString();

            // API patterns
            if (obj.ContainsKey("api_patterns") && obj["api_patterns"].ValueKind == JsonValueKind.Array)
            {
                foreach (var p in obj["api_patterns"].EnumerateArray())
                {
                    var pName = p.GetString();
                    if (!string.IsNullOrEmpty(pName))
                        entry.ApiPatterns.Add(pName);
                }
            }

            return entry;
        }

        private static void WriteToolCallFrequency(StringBuilder sb, List<ParsedEntry> toolEntries)
        {
            sb.AppendLine("## TOOL_CALL_FREQUENCY");
            sb.AppendLine("tool                          | calls | success_rate | avg_ms");

            var grouped = toolEntries.GroupBy(e => e.Tool)
                .OrderByDescending(g => g.Count())
                .ToList();

            foreach (var g in grouped)
            {
                var total = g.Count();
                var success = g.Count(e => e.Success);
                var rate = total > 0 ? 100.0 * success / total : 0;
                var avgMs = total > 0 ? (long)g.Average(e => e.DurationMs) : 0;
                sb.AppendLine($"{g.Key,-30}| {total,5} | {rate,10:F0}%  | {avgMs,6}");
            }
            sb.AppendLine();
        }

        private static void WriteExecuteCodeBreakdown(StringBuilder sb, List<ParsedEntry> execEntries)
        {
            if (execEntries.Count == 0) return;

            int total = execEntries.Count;
            int success = execEntries.Count(e => e.Success);
            int failed = total - success;

            int compilationErrors = execEntries.Count(e => !e.Success && e.ErrorCategory == "compilation");
            int runtimeErrors = execEntries.Count(e => !e.Success && e.ErrorCategory == "runtime");
            int exceptions = execEntries.Count(e => !e.Success && e.ErrorCategory == "exception");
            int otherErrors = failed - compilationErrors - runtimeErrors - exceptions;

            int logicalNoOutput = execEntries.Count(e => e.Success && e.LogicalWarning == "no_output");
            int logicalZeroResults = execEntries.Count(e => e.Success && e.LogicalWarning == "zero_results");
            int logicalTotal = logicalNoOutput + logicalZeroResults;

            sb.AppendLine("## EXECUTECODE_FAILURE_BREAKDOWN");
            sb.AppendLine($"total: {total}, success: {success}, failed: {failed}");
            if (compilationErrors > 0) sb.AppendLine($"compilation_errors: {compilationErrors}");
            if (runtimeErrors > 0) sb.AppendLine($"runtime_errors: {runtimeErrors}");
            if (exceptions > 0) sb.AppendLine($"exceptions: {exceptions}");
            if (otherErrors > 0) sb.AppendLine($"other_errors: {otherErrors}");
            if (logicalTotal > 0)
                sb.AppendLine($"logical_failures: {logicalTotal} (zero_results: {logicalZeroResults}, no_output: {logicalNoOutput})");
            sb.AppendLine();
        }

        private static void WriteApiPatternFailureRates(StringBuilder sb, List<ParsedEntry> execEntries)
        {
            if (execEntries.Count == 0) return;

            // Aggregate: for each API pattern, count total appearances and failures
            var patternStats = new Dictionary<string, (int total, int failures, Dictionary<string, int> errorCounts)>();

            foreach (var entry in execEntries)
            {
                foreach (var pattern in entry.ApiPatterns)
                {
                    if (!patternStats.ContainsKey(pattern))
                        patternStats[pattern] = (0, 0, new Dictionary<string, int>());

                    var (tot, fail, errors) = patternStats[pattern];
                    tot++;
                    if (!entry.Success)
                    {
                        fail++;
                        var snippet = TruncateError(entry.ErrorSnippet);
                        if (!string.IsNullOrEmpty(snippet))
                        {
                            if (!errors.ContainsKey(snippet)) errors[snippet] = 0;
                            errors[snippet]++;
                        }
                    }
                    else if (!string.IsNullOrEmpty(entry.LogicalWarning))
                    {
                        fail++; // logical failures count too
                    }
                    patternStats[pattern] = (tot, fail, errors);
                }
            }

            if (patternStats.Count == 0) return;

            sb.AppendLine("## API_PATTERN_FAILURE_RATES");
            sb.AppendLine("pattern                       | total | failures | failure_rate | top_error");

            foreach (var kv in patternStats.OrderByDescending(x => x.Value.failures > 0 ? (double)x.Value.failures / x.Value.total : -1))
            {
                var (tot, fail, errors) = kv.Value;
                var rate = tot > 0 ? 100.0 * fail / tot : 0;
                var topError = errors.Count > 0
                    ? errors.OrderByDescending(e => e.Value).First().Key
                    : "(none)";
                sb.AppendLine($"{kv.Key,-30}| {tot,5} | {fail,8} | {rate,10:F0}%  | {topError}");
            }
            sb.AppendLine();
        }

        private static void WriteRetrySequences(StringBuilder sb, List<ParsedEntry> execEntries)
        {
            // Group consecutive ExecuteCode entries within same turn_id
            // sharing same description or overlapping api_patterns
            var retryGroups = new List<List<ParsedEntry>>();
            var byTurn = execEntries
                .Where(e => !string.IsNullOrEmpty(e.TurnId) && e.TurnId != "unknown")
                .GroupBy(e => e.TurnId)
                .ToList();

            foreach (var turnGroup in byTurn)
            {
                var ordered = turnGroup.OrderBy(e => e.Seq).ToList();
                if (ordered.Count < 2) continue;

                var currentGroup = new List<ParsedEntry> { ordered[0] };

                for (int i = 1; i < ordered.Count; i++)
                {
                    var prev = ordered[i - 1];
                    var curr = ordered[i];

                    bool isRetry = false;

                    // Same description
                    if (!string.IsNullOrEmpty(prev.Description) && !string.IsNullOrEmpty(curr.Description)
                        && string.Equals(prev.Description, curr.Description, StringComparison.OrdinalIgnoreCase))
                        isRetry = true;

                    // Overlapping API patterns
                    if (!isRetry && prev.ApiPatterns.Count > 0 && curr.ApiPatterns.Count > 0)
                    {
                        if (prev.ApiPatterns.Intersect(curr.ApiPatterns).Any())
                            isRetry = true;
                    }

                    if (isRetry)
                    {
                        currentGroup.Add(curr);
                    }
                    else
                    {
                        if (currentGroup.Count >= 2)
                            retryGroups.Add(currentGroup);
                        currentGroup = new List<ParsedEntry> { curr };
                    }
                }
                if (currentGroup.Count >= 2)
                    retryGroups.Add(currentGroup);
            }

            if (retryGroups.Count == 0) return;

            sb.AppendLine("## RETRY_SEQUENCES");
            foreach (var group in retryGroups)
            {
                var turnId = group[0].TurnId;
                var desc = group.FirstOrDefault(e => !string.IsNullOrEmpty(e.Description))?.Description ?? "(no description)";
                var patterns = group.SelectMany(e => e.ApiPatterns).Distinct().ToList();
                var patternStr = patterns.Count > 0 ? string.Join(",", patterns) : "unknown";
                var outcome = group.Last().Success ? "success" : "failed";

                sb.AppendLine($"turn={turnId} | attempts={group.Count} | pattern={patternStr} | desc=\"{desc}\" | outcome={outcome}");
                foreach (var entry in group)
                {
                    var status = entry.Success ? "success" : (entry.ErrorCategory ?? "failed");
                    var snippet = TruncateError(entry.ErrorSnippet, 80);
                    if (entry.Success)
                        sb.AppendLine($"  seq={entry.Seq}: success (duration={entry.DurationMs}ms)");
                    else
                        sb.AppendLine($"  seq={entry.Seq}: {status} — \"{snippet}\"");
                }
            }
            sb.AppendLine();
        }

        private static void WriteToolCallSequences(StringBuilder sb, List<ParsedEntry> toolEntries)
        {
            // Group by turn_id, extract tool chains
            var chainCounts = new Dictionary<string, int>();

            var byTurn = toolEntries
                .Where(e => !string.IsNullOrEmpty(e.TurnId) && e.TurnId != "unknown")
                .GroupBy(e => e.TurnId)
                .ToList();

            foreach (var turnGroup in byTurn)
            {
                var ordered = turnGroup.OrderBy(e => e.Seq).ToList();
                if (ordered.Count < 2) continue;

                // Build annotated tool names
                var toolNames = ordered.Select(e =>
                {
                    if (e.Tool.Equals("ExecuteCode", StringComparison.OrdinalIgnoreCase) && e.ApiPatterns.Count > 0)
                        return $"ExecuteCode({e.ApiPatterns[0]})";
                    return e.Tool;
                }).ToList();

                // 2-step chains
                for (int i = 0; i < toolNames.Count - 1; i++)
                {
                    var chain = $"{toolNames[i]} → {toolNames[i + 1]}";
                    if (!chainCounts.ContainsKey(chain)) chainCounts[chain] = 0;
                    chainCounts[chain]++;
                }
            }

            if (chainCounts.Count == 0) return;

            sb.AppendLine("## TOOL_CALL_SEQUENCES");
            foreach (var kv in chainCounts.OrderByDescending(x => x.Value).Take(15))
            {
                sb.AppendLine($"{kv.Key,-55}: {kv.Value}x");
            }
            sb.AppendLine();
        }

        private static void WriteCommonErrors(StringBuilder sb, List<ParsedEntry> toolEntries)
        {
            var failedEntries = toolEntries.Where(e => !e.Success && !string.IsNullOrEmpty(e.ErrorSnippet)).ToList();
            if (failedEntries.Count == 0) return;

            // Group by (tool, truncated error)
            var errorGroups = failedEntries
                .GroupBy(e => new { e.Tool, Snippet = TruncateError(e.ErrorSnippet, 60) })
                .Select(g => new { g.Key.Tool, g.Key.Snippet, Count = g.Count() })
                .OrderByDescending(x => x.Count)
                .Take(10)
                .ToList();

            sb.AppendLine("## COMMON_ERROR_MESSAGES");
            sb.AppendLine("count | tool                | error_snippet");
            foreach (var e in errorGroups)
            {
                sb.AppendLine($"{e.Count,5} | {e.Tool,-20}| {e.Snippet}");
            }
            sb.AppendLine();
        }

        private static void WriteToolEvolutionCandidates(StringBuilder sb,
            List<ParsedEntry> execEntries, List<ParsedEntry> allToolEntries)
        {
            var candidates = new List<string>();

            // Rule 1: API pattern with failure_rate >= 30% AND total >= 5
            var patternStats = new Dictionary<string, (int total, int failures)>();
            foreach (var entry in execEntries)
            {
                foreach (var pattern in entry.ApiPatterns)
                {
                    if (!patternStats.ContainsKey(pattern))
                        patternStats[pattern] = (0, 0);
                    var (tot, fail) = patternStats[pattern];
                    tot++;
                    if (!entry.Success || !string.IsNullOrEmpty(entry.LogicalWarning))
                        fail++;
                    patternStats[pattern] = (tot, fail);
                }
            }

            // Rule 2: Count retry sequences per pattern
            var patternRetries = CountRetrySequencesByPattern(execEntries);

            // Collect common errors per pattern
            var patternErrors = new Dictionary<string, List<string>>();
            foreach (var entry in execEntries.Where(e => !e.Success && !string.IsNullOrEmpty(e.ErrorSnippet)))
            {
                foreach (var pattern in entry.ApiPatterns)
                {
                    if (!patternErrors.ContainsKey(pattern))
                        patternErrors[pattern] = new List<string>();
                    patternErrors[pattern].Add(TruncateError(entry.ErrorSnippet, 60));
                }
            }

            foreach (var kv in patternStats)
            {
                var (tot, fail) = kv.Value;
                var rate = tot > 0 ? (double)fail / tot : 0;
                var retries = patternRetries.ContainsKey(kv.Key) ? patternRetries[kv.Key] : 0;

                if ((rate >= 0.30 && tot >= 5) || retries >= 2)
                {
                    var errors = patternErrors.ContainsKey(kv.Key)
                        ? patternErrors[kv.Key].GroupBy(e => e).OrderByDescending(g => g.Count()).Take(3).Select(g => g.Key).ToList()
                        : new List<string>();

                    var errStr = errors.Count > 0 ? string.Join(", ", errors.Select(e => $"\"{e}\"")) : "(none)";

                    candidates.Add(
                        $"CANDIDATE: {kv.Key} (via ExecuteCode)\n" +
                        $"  evidence: {tot} calls, {rate * 100:F0}% failure rate, {retries} retry sequence(s)\n" +
                        $"  common_errors: {errStr}\n" +
                        $"  recommendation: Consider dedicated atomic tool for {kv.Key}");
                }
            }

            // Rule 3: Tool chains appearing >= 10x
            var chainCounts = new Dictionary<string, int>();
            var byTurn = allToolEntries
                .Where(e => !string.IsNullOrEmpty(e.TurnId) && e.TurnId != "unknown")
                .GroupBy(e => e.TurnId);

            foreach (var turnGroup in byTurn)
            {
                var ordered = turnGroup.OrderBy(e => e.Seq).ToList();
                if (ordered.Count < 2) continue;

                var toolNames = ordered.Select(e =>
                {
                    if (e.Tool.Equals("ExecuteCode", StringComparison.OrdinalIgnoreCase) && e.ApiPatterns.Count > 0)
                        return $"ExecuteCode({e.ApiPatterns[0]})";
                    return e.Tool;
                }).ToList();

                for (int i = 0; i < toolNames.Count - 1; i++)
                {
                    var chain = $"{toolNames[i]} → {toolNames[i + 1]}";
                    if (!chainCounts.ContainsKey(chain)) chainCounts[chain] = 0;
                    chainCounts[chain]++;
                }
            }

            foreach (var kv in chainCounts.Where(x => x.Value >= 10))
            {
                candidates.Add(
                    $"CANDIDATE: {kv.Key} workflow\n" +
                    $"  evidence: {kv.Value} occurrences as chain\n" +
                    $"  recommendation: Consider combined tool for this workflow");
            }

            if (candidates.Count == 0) return;

            sb.AppendLine("## TOOL_EVOLUTION_CANDIDATES");
            foreach (var c in candidates)
                sb.AppendLine(c);
            sb.AppendLine();
        }

        private static Dictionary<string, int> CountRetrySequencesByPattern(List<ParsedEntry> execEntries)
        {
            var result = new Dictionary<string, int>();

            var byTurn = execEntries
                .Where(e => !string.IsNullOrEmpty(e.TurnId) && e.TurnId != "unknown")
                .GroupBy(e => e.TurnId);

            foreach (var turnGroup in byTurn)
            {
                var ordered = turnGroup.OrderBy(e => e.Seq).ToList();
                if (ordered.Count < 2) continue;

                var currentGroup = new List<ParsedEntry> { ordered[0] };
                for (int i = 1; i < ordered.Count; i++)
                {
                    var prev = ordered[i - 1];
                    var curr = ordered[i];
                    bool isRetry = false;
                    if (!string.IsNullOrEmpty(prev.Description) && !string.IsNullOrEmpty(curr.Description)
                        && string.Equals(prev.Description, curr.Description, StringComparison.OrdinalIgnoreCase))
                        isRetry = true;
                    if (!isRetry && prev.ApiPatterns.Count > 0 && curr.ApiPatterns.Count > 0
                        && prev.ApiPatterns.Intersect(curr.ApiPatterns).Any())
                        isRetry = true;

                    if (isRetry) currentGroup.Add(curr);
                    else
                    {
                        if (currentGroup.Count >= 2)
                            foreach (var p in currentGroup.SelectMany(e => e.ApiPatterns).Distinct())
                            {
                                if (!result.ContainsKey(p)) result[p] = 0;
                                result[p]++;
                            }
                        currentGroup = new List<ParsedEntry> { curr };
                    }
                }
                if (currentGroup.Count >= 2)
                    foreach (var p in currentGroup.SelectMany(e => e.ApiPatterns).Distinct())
                    {
                        if (!result.ContainsKey(p)) result[p] = 0;
                        result[p]++;
                    }
            }

            return result;
        }

        /// <summary>
        /// Truncate error snippet for display, keeping the most informative part.
        /// Strips common prefixes like "Compilation failed. Fix the errors...:"
        /// and "Runtime error:\n" to get to the actual error.
        /// </summary>
        private static string TruncateError(string snippet, int maxLen = 80)
        {
            if (string.IsNullOrEmpty(snippet)) return "";

            // Strip common ExecuteCode error prefixes
            var cleaned = snippet;
            if (cleaned.StartsWith("Compilation failed"))
            {
                var idx = cleaned.IndexOf(":\n");
                if (idx >= 0 && idx + 2 < cleaned.Length)
                    cleaned = cleaned.Substring(idx + 2);
            }
            else if (cleaned.StartsWith("Runtime error"))
            {
                var idx = cleaned.IndexOf(":\n");
                if (idx >= 0 && idx + 2 < cleaned.Length)
                    cleaned = cleaned.Substring(idx + 2);
            }

            // Take first line only
            var firstLine = cleaned.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault() ?? cleaned;

            if (firstLine.Length > maxLen)
                return firstLine.Substring(0, maxLen) + "...";
            return firstLine;
        }

        #endregion

        /// <summary>
        /// Write a JSON entry to the log file (append-only).
        /// </summary>
        private static void WriteEntry(Dictionary<string, object> entry)
        {
            try
            {
                if (!Directory.Exists(LogDirectory))
                    Directory.CreateDirectory(LogDirectory);

                var json = JsonSerializer.Serialize(entry, new JsonSerializerOptions
                {
                    WriteIndented = false
                });

                lock (_lock)
                {
                    File.AppendAllText(LogFilePath, json + "\n");
                }
            }
            catch
            {
                // Silent fail — tracking should never break the main app
            }
        }
    }
}
